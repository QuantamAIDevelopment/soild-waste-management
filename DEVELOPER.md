# Developer Guide

## Project Structure

```
Solid_waste_management/
├── src/                           # Source code modules
│   ├── api/                       # FastAPI REST endpoints
│   │   ├── geospatial_routes.py   # Main route optimization API
│   │   ├── vehicles_api.py        # Vehicle management endpoints
│   │   └── auth_endpoints.py      # Authentication endpoints
│   ├── clustering/                # Building clustering algorithms
│   │   ├── assign_buildings.py    # KMeans/DBSCAN clustering
│   │   └── trip_assignment.py     # Trip capacity management
│   ├── configurations/            # System configuration
│   │   └── config.py              # Environment and app settings
│   ├── core/                      # Core coordination system
│   │   └── blackboard.py          # Shared state management
│   ├── data_processing/           # Geospatial data processing
│   │   ├── load_road_network.py   # Road network loading and graph building
│   │   └── snap_buildings.py      # Building-to-road snapping
│   ├── models/                    # Data models and schemas
│   │   └── blackboard_entry.py    # Pydantic models
│   ├── routing/                   # Route optimization
│   │   ├── capacity_optimizer.py  # Capacity-based route optimization
│   │   ├── compute_routes.py      # OR-Tools VRP solver
│   │   ├── get_osrm_directions.py # OSRM turn-by-turn directions
│   │   └── hierarchical_clustering.py # Spatial clustering
│   ├── services/                  # External service integration
│   │   ├── vehicle_service.py     # Live vehicle API integration
│   │   ├── auth_service.py        # JWT token management
│   │   └── scheduler_service.py   # Daily scheduling service
│   ├── storage/                   # Data persistence
│   │   └── postgis_store.py       # PostGIS database operations
│   ├── tools/                     # Utility tools
│   │   ├── directions_generator.py # Route directions generation
│   │   ├── improved_clustering.py # Advanced clustering algorithms
│   │   ├── osrm_routing.py        # OSRM routing utilities
│   │   ├── road_snapper.py        # Road network snapping
│   │   └── vrp_solver.py          # Vehicle Routing Problem solver
│   └── visualization/             # Map generation and export
│       ├── export_to_geojson.py   # GeoJSON export utilities
│       └── folium_map.py          # Interactive map generation
├── tests/                         # Test suite
│   ├── test_cluster_endpoint.py   # Cluster API tests
│   ├── test_improved_clustering.py # Clustering algorithm tests
│   ├── test_snapper_vrp.py        # Integration tests
│   └── test_trip_assignment.py    # Trip assignment tests
├── output/                        # Generated results (auto-created)
├── main.py                        # CLI and API entry point
├── requirements.txt               # Python dependencies
├── .env                          # Environment variables
├── .env.example                  # Environment template
├── README.md                     # User documentation
├── DEVELOPER.md                  # This file
├── Dockerfile                    # Docker configuration
├── test_auth.py                  # Authentication testing
└── test_scheduler.py             # Scheduler testing
```

## Development Setup

### Prerequisites
- Python 3.11+
- PostgreSQL with PostGIS (optional)
- Git

### Environment Setup
```bash
# Clone repository
git clone <repository-url>
cd swm

# Create virtual environment
python -m venv venv
source venv/bin/activate  # Linux/Mac
# or
venv\Scripts\activate     # Windows

# Install dependencies
pip install -r requirements.txt

# Copy environment template
cp .env.example .env
# Edit .env with your configuration
```

### Environment Variables
```bash
# SWM API Configuration
SWM_API_BASE_URL=https://uat-swm-main-service-hdaqcdcscbfedhhn.centralindia-01.azurewebsites.net
SWM_USERNAME=your_username
SWM_PASSWORD=your_password
SWM_TOKEN=<auto-generated-jwt-token>

# External Integration
EXTERNAL_UPLOAD_URL=https://uat-swm-main-service-hdaqcdcscbfedhhn.centralindia-01.azurewebsites.net/api/vehicle-routes/upload-data

# Application Configuration
DEBUG=true
PORT=8081
API_KEY=swm-2024-secure-key

# Database (Optional)
DATABASE_URL=postgresql://user:pass@localhost:5432/waste_db
```

**Security Note**: Never commit `.env` file to version control. Use `.env.example` as a template.

## API Development

### Running the API Server
```bash
# Development mode
python main.py --api --port 8081

# Access Swagger UI
http://localhost:8081/docs
```

### Adding New Endpoints
1. Create endpoint in `src/api/geospatial_routes.py` or `src/api/vehicles_api.py`
2. Add Pydantic models in `src/models/`
3. Update OpenAPI tags and documentation

### Authentication
All API endpoints use Bearer token authentication:
```python
from fastapi.security import HTTPBearer
from fastapi import HTTPException, Depends

security = HTTPBearer()
API_KEY = "swm-2024-secure-key"

def verify_api_key(credentials: HTTPAuthorizationCredentials = Depends(security)):
    if credentials.credentials != API_KEY:
        raise HTTPException(status_code=401, detail="Invalid API key")
    return credentials.credentials

@app.get("/protected-endpoint")
async def protected(api_key: str = Depends(verify_api_key)):
    # Endpoint logic here
    pass
```

### JWT Token Management
```python
from src.services.auth_service import AuthService

auth_service = AuthService()
token = auth_service.get_valid_token()  # Auto-refreshes if needed
```

## Core Components

### 1. Route Optimization Pipeline
```python
# Main pipeline in GeospatialRouteOptimizer class (main.py)
def process_ward_data(self, roads_geojson, buildings_geojson, vehicles_csv=None):
    # 1. Load and build road network graph (NetworkX)
    road_gdf = self.road_loader.load_geojson(roads_geojson)
    road_graph = self.road_loader.build_networkx_graph()
    
    # 2. Load and snap buildings to road network
    self.building_snapper = BuildingSnapper(road_graph)
    buildings_gdf = self.building_snapper.load_buildings(buildings_geojson)
    snapped_buildings = self.building_snapper.snap_to_road_network(buildings_gdf)
    
    # 3. Load vehicles from live API and cluster buildings
    vehicles_df = self.clusterer.load_vehicles(vehicles_csv)  # Optional CSV
    clustered_buildings = self.clusterer.cluster_buildings(snapped_buildings, len(vehicles_df))
    
    # 4. Compute optimal routes with trip assignments
    self.route_computer = RouteComputer(road_graph)
    routes = self.route_computer.compute_cluster_routes(clustered_buildings)
    
    # 5. Get OSRM directions with turn-by-turn navigation
    directions = self.directions_provider.get_route_directions(coordinates)
    
    # 6. Export results and generate interactive maps
    self.exporter.export_routes_geojson(routes_path)
    self.map_generator.create_route_map(routes_gdf, clustered_buildings)
```

### Key Implementation: Cluster-Based Route Assignment

The system implements a **two-phase clustering strategy**:

**Phase 1: Create Fixed Clusters (Based on TOTAL Vehicles)**
```python
# Create clusters using ALL vehicles (active + inactive)
total_vehicles = len(vehicles_df)  # e.g., 7 vehicles
clusters = create_clusters(buildings, num_clusters=total_vehicles)
# Result: 7 fixed spatial clusters
```

**Phase 2: Assign Routes (Based on ACTIVE Vehicles Only)**
```python
# Filter active vehicles for route assignment
active_vehicles = vehicles_df[vehicles_df['status'].isin(['ACTIVE', 'AVAILABLE', 'ONLINE'])]
active_count = len(active_vehicles)  # e.g., 4 active vehicles

# Distribute all clusters among active vehicles
clusters_per_vehicle = total_vehicles // active_count  # 7 // 4 = 1
remaining = total_vehicles % active_count  # 7 % 4 = 3

# Distribution:
# Vehicle 1: clusters 0, 1 (2 clusters)
# Vehicle 2: clusters 2, 3 (2 clusters)  
# Vehicle 3: clusters 4, 5 (2 clusters)
# Vehicle 4: cluster 6 (1 cluster)
```

**Benefits:**
- Consistent cluster boundaries (never change)
- Fair workload distribution among active vehicles
- Easy to scale when vehicles become active/inactive
- Each active vehicle handles multiple clusters through multiple trips

### 2. Clustering Algorithm
```python
# Building clustering with vehicle capacity
from src.clustering.assign_buildings import BuildingClusterer
from src.services.vehicle_service import VehicleService

# Live vehicle data integration (ALL vehicles including inactive)
vehicle_service = VehicleService()
vehicles_df = vehicle_service.get_vehicles_by_ward(ward_no, include_all_status=True)

# Two-phase clustering
clusterer = BuildingClusterer()
clusterer.load_vehicles(vehicles_csv)  # Optional CSV override

# Phase 1: Create clusters based on TOTAL vehicles
total_vehicles = len(vehicles_df)
clustered_buildings = clusterer.cluster_buildings_with_vehicles(buildings, vehicles_df)

# Phase 2: Assign routes to ACTIVE vehicles only
active_vehicles = vehicles_df[vehicles_df['status'].str.upper().isin(['ACTIVE', 'AVAILABLE', 'ONLINE'])]
route_assignments = assign_clusters_to_active_vehicles(clustered_buildings, active_vehicles)

print(f"Clusters: {total_vehicles}, Active vehicles: {len(active_vehicles)}")
print(f"Each active vehicle handles ~{total_vehicles // len(active_vehicles)} clusters")
```

### 3. Route Computation
```python
# OR-Tools VRP solver with capacity constraints
from src.routing.compute_routes import RouteComputer
from src.routing.capacity_optimizer import CapacityRouteOptimizer

# Standard route computation
route_computer = RouteComputer(road_graph)
routes = route_computer.compute_cluster_routes(clustered_buildings)

# Capacity-based optimization (used in API)
optimizer = CapacityRouteOptimizer(max_houses_per_trip=500)

# Get ALL vehicles (including inactive) for clustering
all_vehicles = vehicle_service.get_vehicles_by_ward(ward_no, include_all_status=True)

# Optimization creates clusters from total vehicles, assigns routes to active only
optimization_result = optimizer.optimize_routes_with_capacity(
    buildings_gdf, all_vehicles, roads_gdf
)

# Access route assignments (only active vehicles have routes)
for vehicle_id, assignment in optimization_result['route_assignments'].items():
    vehicle_info = assignment['vehicle_info']
    trips = assignment['trips']
    clusters_assigned = len(trips)  # Each trip = 1 cluster
    print(f"Vehicle {vehicle_id} (ACTIVE): {clusters_assigned} clusters, {len(trips)} trips")

print(f"Total clusters: {optimization_result['total_vehicles_in_ward']}")
print(f"Active vehicles with routes: {optimization_result['active_vehicles']}")
```

### 4. Map Generation
```python
# Interactive Folium maps with cluster controls
from src.visualization.folium_map import FoliumMapGenerator

map_generator = FoliumMapGenerator()

# Route map with interactive controls
route_map = map_generator.create_route_map(routes_gdf, clustered_buildings)
map_generator.save_map(route_map, "output/route_map.html")

# Cluster analysis map
cluster_map = map_generator.create_cluster_analysis_map(clustered_buildings)
map_generator.save_map(cluster_map, "output/cluster_analysis.html")

# Maps include:
# - Color-coded routes and buildings
# - Layer controls for show/hide clusters
# - Interactive dashboard panel
# - Start/end markers with vehicle info
# - Directional arrows along routes
```

## Testing

### Running Tests
```bash
# All tests
pytest tests/ -v

# Specific test
pytest tests/test_snapper_vrp.py::TestIntegration::test_end_to_end_small_dataset -v

# With coverage
pytest tests/ --cov=src --cov-report=html
```

### Test Structure
- `tests/test_*.py` - Unit tests for individual modules
- `tests/test_*_integration.py` - Integration tests
- Mock external APIs and services in tests

### Adding Tests
```python
import pytest
from src.module import YourClass

class TestYourClass:
    def test_method(self):
        instance = YourClass()
        result = instance.method()
        assert result == expected_value
```

## Data Flow

### 1. Input Processing
```
GeoJSON Files → GeoPandas → CRS Conversion → NetworkX Graph
CSV Files → Pandas → Data Validation → Active Vehicle Filtering
```

### 2. Optimization Flow
```
Buildings → Snap to Roads → Cluster by Vehicle → VRP Solver → Routes
Vehicles → Filter Active → Assign to Clusters → Capacity Check → Trips
```

### 3. Output Generation
```
Routes → GeoJSON Export → Interactive Maps → Browser Display
Results → CSV Summary → API Response → Client Integration
```

## Configuration

### System Configuration
Edit `src/configurations/config.py`:
```python
class Config:
    # Database settings (optional)
    DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://postgres:pass@localhost:5432/swm")
    
    # Spatial reference systems
    TARGET_CRS = "EPSG:3857"  # Web Mercator for calculations
    
    # Vehicle capacity settings
    HOUSES_PER_VEHICLE_PER_TRIP = 500
    MAX_TRIPS_PER_DAY = 3
    
    # VRP solver settings
    VRP_TIME_LIMIT_SECONDS = 30
    VRP_VEHICLE_CAPACITY = 999999  # Effectively infinite
    
    # File upload settings
    MAX_FILE_SIZE_MB = 100
    UPLOAD_DIR = "uploads"
    
    # API settings
    API_HOST = "127.0.0.1"
    API_PORT = 8080
    
    # Deterministic results
    RANDOM_SEED = 42
```

### API Configuration
```python
# FastAPI app configuration in src/api/geospatial_routes.py
app = FastAPI(
    title="Geospatial AI Route Optimizer",
    description="Dynamic garbage collection route optimization using live vehicle data and road network",
    version="2.0.0",
    openapi_tags=[
        {"name": "clusters", "description": "Cluster management and road coordinate retrieval"},
        {"name": "optimization", "description": "Route optimization operations"},
        {"name": "maps", "description": "Map generation and visualization"},
        {"name": "scheduler", "description": "Automatic daily scheduling operations"}
    ]
)

# CORS middleware for web integration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(vehicles_router)  # Vehicle management
app.include_router(auth_router)      # Authentication
```

## Performance Optimization

### 1. Spatial Operations
- **CRS Management**: EPSG:4326 for display, EPSG:3857 for distance calculations
- **Spatial Indexing**: GeoPandas spatial operations for fast nearest neighbor queries
- **NetworkX Graphs**: Efficient shortest path calculations on road networks
- **Batch Processing**: Process large datasets in chunks to manage memory

### 2. Clustering Optimization
- **Vehicle-based Clustering**: k = number of active vehicles for optimal resource utilization
- **Capacity Constraints**: 500 houses per trip, max 3 trips per vehicle per day
- **Ward Filtering**: Process only relevant vehicles for targeted optimization
- **Deterministic Results**: Fixed random seed for reproducible clustering

### 3. Memory Management
- **Temporary File Cleanup**: Automatic removal of generated maps after serving
- **Session Reuse**: HTTP session pooling for API calls
- **Token Caching**: JWT tokens cached and auto-refreshed
- **Streaming**: Large GeoJSON files processed incrementally

### 4. API Performance
- **Authentication Caching**: Bearer tokens validated once per request
- **Response Compression**: JSON responses with numpy type conversion
- **Timeout Management**: 30-second timeouts for external API calls
- **Error Handling**: Graceful fallback to cached/default data

## Debugging

### Logging Configuration
```python
from loguru import logger

# Enable debug logging
logger.add("debug.log", level="DEBUG")
logger.debug("Debug message")
logger.info("Info message")
logger.error("Error message")
```

### Common Issues
1. **Import Errors**: Ensure all imports use `src.` prefix and modules are in PYTHONPATH
2. **CRS Mismatches**: Always convert to EPSG:4326 for display, EPSG:3857 for calculations
3. **Memory Issues**: Process large datasets in chunks, clean up temporary files
4. **API Timeouts**: Increase timeout for large optimization problems (30s default)
5. **Token Expiration**: JWT tokens auto-refresh, check auth_service logs if issues persist
6. **Port Conflicts**: Default port 8081, use `--port` flag to change if occupied
7. **Vehicle Data**: If no vehicles found, check ward number and API connectivity
8. **Map Generation**: Maps auto-delete after serving, use `/generate-map` to regenerate
9. **No Active Vehicles**: System returns error if no active vehicles in ward - check vehicle status
10. **Cluster Count Mismatch**: Clusters = total vehicles, routes = active vehicles only

### Important Implementation Notes

**Two-Phase Clustering Logic**
```python
# CORRECT: Get ALL vehicles for clustering
all_vehicles = vehicle_service.get_vehicles_by_ward(ward_no, include_all_status=True)
total_count = len(all_vehicles)  # Used for cluster count

# Create clusters based on total vehicles
clusters = create_clusters(buildings, num_clusters=total_count)

# THEN filter active vehicles for route assignment
active_vehicles = all_vehicles[all_vehicles['status'].str.upper().isin(['ACTIVE', 'AVAILABLE', 'ONLINE'])]

# Distribute all clusters among active vehicles
assign_clusters_to_vehicles(clusters, active_vehicles)
```

**Key Files for Two-Phase Implementation**
- `src/routing/capacity_optimizer.py`: `_assign_active_vehicles_to_clusters()` method
- `src/clustering/assign_buildings.py`: `cluster_buildings_with_vehicles()` method
- `src/api/geospatial_routes.py`: `/optimize-routes` endpoint logic

**Status Filtering**
```python
# Valid active statuses
ACTIVE_STATUSES = ['ACTIVE', 'AVAILABLE', 'ONLINE', 'READY', 'OPERATIONAL', 'IN_SERVICE']

# Filter active vehicles
active = vehicles_df[vehicles_df['status'].str.upper().isin(ACTIVE_STATUSES)]
```

## Deployment

### Production Setup
```bash
# Install production dependencies
pip install gunicorn

# Run with Gunicorn (from main.py)
gunicorn -w 4 -k uvicorn.workers.UvicornWorker src.api.geospatial_routes:app --bind 0.0.0.0:8081

# Or use the main.py entry point
python main.py --api --port 8081
```

### Docker Deployment
```dockerfile
FROM python:3.11-slim

# Install system dependencies for geospatial libraries
RUN apt-get update && apt-get install -y \
    gdal-bin \
    libgdal-dev \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .
EXPOSE 8081

# Create output directory
RUN mkdir -p output

# Run API server by default
CMD ["python", "main.py", "--api", "--port", "8081"]
```

### Environment Variables for Production
```bash
# Security
DEBUG=false
API_KEY=<secure-production-key>

# SWM API
SWM_API_BASE_URL=<production-swm-api-url>
SWM_USERNAME=<production-username>
SWM_PASSWORD=<secure-password>

# External Integration
EXTERNAL_UPLOAD_URL=<production-external-api>

# Database (optional)
DATABASE_URL=<production-database-url>

# Performance
VRP_TIME_LIMIT_SECONDS=60
MAX_FILE_SIZE_MB=500
```

## Security Best Practices

### Environment Variables
- Never commit `.env` file with credentials to Git
- Use `.env.example` as a template for team members
- Rotate API keys and JWT tokens regularly
- Use different credentials for UAT and production

### API Security
- All endpoints require Bearer token authentication
- JWT tokens auto-refresh before expiration
- Use HTTPS in production environments
- Implement rate limiting for public-facing APIs

## Contributing

### Code Style
- Follow PEP 8 style guidelines
- Use type hints for function parameters and returns
- Add docstrings for all public methods
- Keep functions focused and single-purpose

### Git Workflow
```bash
# Create feature branch
git checkout -b feature/new-feature

# Make changes and commit
git add .
git commit -m "Add new feature"

# Push and create PR
git push origin feature/new-feature
```

### Code Review Checklist
- [ ] All tests pass
- [ ] Code follows style guidelines
- [ ] Documentation updated
- [ ] No hardcoded values
- [ ] Error handling implemented
- [ ] Performance considerations addressed